
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async changeBinding(id: string, binding: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_binding", { id, binding }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetBinding(id: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePttSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ptt_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackVolumeSetting(volume: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_volume_setting", { volume }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSoundThemeSetting(theme: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_sound_theme_setting", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeStartHiddenSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_start_hidden_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutostartSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_autostart_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeTranslateToEnglishSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_translate_to_english_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSelectedLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_selected_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeOverlayPositionSetting(position: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_overlay_position_setting", { position }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDebugModeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_debug_mode_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWordCorrectionThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_word_correction_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePasteMethodSetting(method: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_paste_method_setting", { method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeClipboardHandlingSetting(handling: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_clipboard_handling_setting", { handling }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessBaseUrlSetting(providerId: string, baseUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_base_url_setting", { providerId, baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessApiKeySetting(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_api_key_setting", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPostProcessModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_post_process_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPostProcessPrompt(name: string, prompt: string) : Promise<Result<LLMPrompt, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_post_process_prompt", { name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePostProcessPrompt(id: string, name: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_post_process_prompt", { id, name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePostProcessPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_post_process_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessSelectedPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_selected_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomWords(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Temporarily unregister a binding while the user is editing it in the UI.
 * This avoids firing the action while keys are being recorded.
 */
async suspendBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Re-register the binding after the user has finished editing.
 */
async resumeBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMuteWhileRecordingSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_mute_while_recording_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppendTrailingSpaceSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_append_trailing_space_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_app_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUpdateChecksSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_update_checks_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSnippetsEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_snippets_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSnippets(snippets: Snippet[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_snippets", { snippets }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutoFormatEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_auto_format_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutoFormatListsSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_auto_format_lists_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeVerbalCommandsEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_verbal_commands_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeToneAdjustmentEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_tone_adjustment_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDefaultToneSetting(tone: ToneStyle) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_default_tone_setting", { tone }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateAppToneMappings(mappings: Partial<{ [key in string]: ToneStyle }>) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_app_tone_mappings", { mappings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDeveloperModeSetting(mode: DeveloperMode) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_developer_mode_setting", { mode }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePreserveCodeSyntaxSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_preserve_code_syntax_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDeveloperDictionary(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_developer_dictionary", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeCorrectionDetectionEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_correction_detection_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeContextAwarenessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_context_awareness_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateContextPerAppPermissions(permissions: Partial<{ [key in string]: boolean }>) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_context_per_app_permissions", { permissions }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeGroqTranscriptionApiKeySetting(apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_groq_transcription_api_key_setting", { apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMultilingualModeEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_multilingual_mode_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePrimaryLanguageSetting(language: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_primary_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSecondaryLanguageSetting(language: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_secondary_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeLanguageDetectionSensitivitySetting(sensitivity: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_language_detection_sensitivity_setting", { sensitivity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeShowMeetingMenuSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_show_meeting_menu_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingModeEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_mode_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingChunkDurationSetting(seconds: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_chunk_duration_setting", { seconds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingAutoSummarizeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_auto_summarize_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingExtractActionItemsSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_extract_action_items_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingSummaryPromptSetting(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_summary_prompt_setting", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMeetingActionItemsPromptSetting(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_meeting_action_items_prompt_setting", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeLivePreviewEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_live_preview_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeLivePreviewIntervalSetting(intervalMs: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_live_preview_interval_setting", { intervalMs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWhisperModeEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_whisper_mode_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeVadThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_vad_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current meeting state
 */
async getMeetingState() : Promise<Result<MeetingState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_meeting_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current meeting session if any
 */
async getCurrentMeetingSession() : Promise<Result<MeetingSession | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_meeting_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get elapsed time in seconds since meeting started
 */
async getMeetingElapsedSeconds() : Promise<Result<number | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_meeting_elapsed_seconds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new meeting
 */
async startMeeting(bindingId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_meeting", { bindingId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the current meeting
 */
async stopMeeting(meetingId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_meeting", { meetingId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel the current meeting without processing
 */
async cancelMeeting(meetingId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_meeting", { meetingId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get meeting history entries
 */
async getMeetingHistory() : Promise<Result<MeetingHistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_meeting_history") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a meeting from history
 */
async deleteMeeting(meetingId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_meeting", { meetingId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async triggerUpdateCheck() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_update_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelOperation() : Promise<void> {
    await TAURI_INVOKE("cancel_operation");
},
async getAppDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLogLevel(level: LogLevel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_log_level", { level }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openRecordingsFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_recordings_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openAppDataDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Apple Intelligence is available on this device.
 * Called by the frontend when the user selects Apple Intelligence provider.
 */
async checkAppleIntelligenceAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("check_apple_intelligence_available");
},
/**
 * Try to initialize Enigo (keyboard/mouse simulation).
 * On macOS, this will return an error if accessibility permissions are not granted.
 */
async initializeEnigo() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("initialize_enigo") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableModels() : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getModelInfo(modelId: string) : Promise<Result<ModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCurrentModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_transcription_model_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isModelLoading() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_model_loading") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsAvailable() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsOrDownloads() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_or_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecommendedFirstModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recommended_first_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download CoreML model for Apple Neural Engine acceleration (macOS only)
 */
async downloadCoremlModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_coreml_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete CoreML model (macOS only)
 */
async deleteCoremlModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_coreml_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if running on macOS (for UI to show/hide CoreML options)
 */
async isCoremlAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("is_coreml_available");
},
/**
 * Validate a Groq API key before using it
 * Returns Ok(()) if valid, or an error message if invalid
 */
async validateGroqApiKey(apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_groq_api_key", { apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if a model requires an API key (cloud models)
 */
async modelRequiresApiKey(modelId: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("model_requires_api_key", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if Groq API key is configured in settings
 */
async isGroqApiKeyConfigured() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_groq_api_key_configured") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateMicrophoneMode(alwaysOn: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_microphone_mode", { alwaysOn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMicrophoneMode() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_microphone_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableMicrophones() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_microphones") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableOutputDevices() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_output_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedOutputDevice(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_output_device", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedOutputDevice() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_output_device") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playTestSound(soundType: string) : Promise<void> {
    await TAURI_INVOKE("play_test_sound", { soundType });
},
async checkCustomSounds() : Promise<CustomSounds> {
    return await TAURI_INVOKE("check_custom_sounds");
},
async setClamshellMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_clamshell_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getClamshellMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_clamshell_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<boolean> {
    return await TAURI_INVOKE("is_recording");
},
/**
 * Get information about system audio capture for the current platform
 */
async getSystemAudioInfo() : Promise<SystemAudioInfo> {
    return await TAURI_INVOKE("get_system_audio_info");
},
/**
 * Check if native system audio capture is available
 */
async isNativeSystemAudioAvailable() : Promise<boolean> {
    return await TAURI_INVOKE("is_native_system_audio_available");
},
/**
 * Start native system audio capture
 */
async startSystemAudioCapture() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_system_audio_capture") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop native system audio capture and return samples
 */
async stopSystemAudioCapture() : Promise<Result<number[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_system_audio_capture") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if currently capturing system audio
 */
async isCapturingSystemAudio() : Promise<boolean> {
    return await TAURI_INVOKE("is_capturing_system_audio");
},
/**
 * Get the current diarization status
 */
async getDiarizationStatus() : Promise<DiarizationStatus> {
    return await TAURI_INVOKE("get_diarization_status");
},
/**
 * Enable or disable diarization
 */
async changeDiarizationEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_diarization_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get information about required models
 */
async getDiarizationModelInfo() : Promise<DiarizationModelInfo[]> {
    return await TAURI_INVOKE("get_diarization_model_info");
},
/**
 * Download diarization models
 */
async downloadDiarizationModels() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_diarization_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setModelUnloadTimeout(timeout: ModelUnloadTimeout) : Promise<void> {
    await TAURI_INVOKE("set_model_unload_timeout", { timeout });
},
async getModelLoadStatus() : Promise<Result<ModelLoadStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_load_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadModelManually() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unload_model_manually") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryEntries() : Promise<Result<HistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleHistoryEntrySaved(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_history_entry_saved", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioFilePath(fileName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_file_path", { fileName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryEntry(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_entry", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateHistoryLimit(limit: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_history_limit", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateRecordingRetentionPeriod(period: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_recording_retention_period", { period }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of supported file extensions
 */
async getSupportedFileExtensions() : Promise<string[]> {
    return await TAURI_INVOKE("get_supported_file_extensions");
},
/**
 * Queue a file for transcription
 */
async queueFileForTranscription(filePath: string) : Promise<Result<FileTranscriptionJob, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("queue_file_for_transcription", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Queue multiple files for transcription
 */
async queueFilesForTranscription(filePaths: string[]) : Promise<Result<FileTranscriptionJob[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("queue_files_for_transcription", { filePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Process the next queued file
 */
async processNextFile() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("process_next_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Process all queued files (runs on background thread to avoid blocking UI)
 */
async processAllFiles() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("process_all_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel the current file transcription
 */
async cancelFileTranscription() : Promise<void> {
    await TAURI_INVOKE("cancel_file_transcription");
},
/**
 * Cancel a specific job by ID
 */
async cancelFileTranscriptionJob(jobId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_file_transcription_job", { jobId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all transcription jobs
 */
async getFileTranscriptionJobs() : Promise<FileTranscriptionJob[]> {
    return await TAURI_INVOKE("get_file_transcription_jobs");
},
/**
 * Get a specific job by ID
 */
async getFileTranscriptionJob(jobId: string) : Promise<FileTranscriptionJob | null> {
    return await TAURI_INVOKE("get_file_transcription_job", { jobId });
},
/**
 * Clear completed, failed, and cancelled jobs
 */
async clearCompletedFileJobs() : Promise<void> {
    await TAURI_INVOKE("clear_completed_file_jobs");
},
/**
 * Remove a specific job
 */
async removeFileTranscriptionJob(jobId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_file_transcription_job", { jobId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if file transcription is currently processing
 */
async isFileTranscriptionProcessing() : Promise<boolean> {
    return await TAURI_INVOKE("is_file_transcription_processing");
},
/**
 * Export a transcript in the specified format
 */
async exportTranscript(text: string, format: ExportFormat, title: string | null, sourceFile: string | null, durationMs: number | null, segments: TranscriptSegment[] | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_transcript", { text, format, title, sourceFile, durationMs, segments }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Export a transcript and save to file
 */
async exportTranscriptToFile(text: string, format: ExportFormat, filePath: string, title: string | null, sourceFile: string | null, durationMs: number | null, segments: TranscriptSegment[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_transcript_to_file", { text, format, filePath, title, sourceFile, durationMs, segments }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the appropriate file extension for a format
 */
async getExportFileExtension(format: ExportFormat) : Promise<string> {
    return await TAURI_INVOKE("get_export_file_extension", { format });
},
/**
 * Get all available export formats
 */
async getAvailableExportFormats() : Promise<ExportFormat[]> {
    return await TAURI_INVOKE("get_available_export_formats");
},
/**
 * Get all configured watch folders
 */
async getWatchFolders() : Promise<WatchFolderConfig[]> {
    return await TAURI_INVOKE("get_watch_folders");
},
/**
 * Add a new watch folder
 */
async addWatchFolder(path: string, recursive: boolean) : Promise<Result<WatchFolderConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_watch_folder", { path, recursive }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a watch folder
 */
async removeWatchFolder(folderId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_watch_folder", { folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a watch folder configuration
 */
async updateWatchFolder(config: WatchFolderConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_watch_folder", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the status of all watch folders
 */
async getWatchFolderStatus() : Promise<WatchFolderStatus[]> {
    return await TAURI_INVOKE("get_watch_folder_status");
},
/**
 * Start watching a specific folder
 */
async startWatchFolder(folderId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_watch_folder", { folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop watching a specific folder
 */
async stopWatchFolder(folderId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_watch_folder", { folderId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the Mac is a laptop by detecting battery presence
 * 
 * This uses pmset to check for battery information.
 * Returns true if a battery is detected (laptop), false otherwise (desktop)
 */
async isLaptop() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_laptop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AppSettings = { bindings: Partial<{ [key in string]: ShortcutBinding }>; push_to_talk: boolean; audio_feedback: boolean; audio_feedback_volume?: number; sound_theme?: SoundTheme; start_hidden?: boolean; autostart_enabled?: boolean; update_checks_enabled?: boolean; selected_model?: string; always_on_microphone?: boolean; selected_microphone?: string | null; clamshell_microphone?: string | null; selected_output_device?: string | null; translate_to_english?: boolean; selected_language?: string; overlay_position?: OverlayPosition; debug_mode?: boolean; log_level?: LogLevel; custom_words?: string[]; model_unload_timeout?: ModelUnloadTimeout; word_correction_threshold?: number; history_limit?: number; recording_retention_period?: RecordingRetentionPeriod; paste_method?: PasteMethod; clipboard_handling?: ClipboardHandling; post_process_enabled?: boolean; post_process_provider_id?: string; post_process_providers?: PostProcessProvider[]; post_process_api_keys?: Partial<{ [key in string]: string }>; post_process_models?: Partial<{ [key in string]: string }>; post_process_prompts?: LLMPrompt[]; post_process_selected_prompt_id?: string | null; mute_while_recording?: boolean; append_trailing_space?: boolean; app_language?: string; snippets?: Snippet[]; snippets_enabled?: boolean; auto_format_enabled?: boolean; auto_format_lists?: boolean; verbal_commands_enabled?: boolean; tone_adjustment_enabled?: boolean; default_tone?: ToneStyle; app_tone_mappings?: Partial<{ [key in string]: ToneStyle }>; developer_mode?: DeveloperMode; preserve_code_syntax?: boolean; developer_dictionary?: string[]; correction_detection_enabled?: boolean; context_awareness_enabled?: boolean; context_per_app_permissions?: Partial<{ [key in string]: boolean }>; groq_transcription_api_key?: string; multilingual_mode_enabled?: boolean; primary_language?: string | null; secondary_language?: string | null; language_detection_sensitivity?: number; show_meeting_menu?: boolean; meeting_mode_enabled?: boolean; meeting_chunk_duration_seconds?: number; meeting_auto_summarize?: boolean; meeting_extract_action_items?: boolean; meeting_summary_prompt?: string; meeting_action_items_prompt?: string; live_preview_enabled?: boolean; live_preview_interval_ms?: number; watch_folders?: WatchFolderConfig[] | null; whisper_mode_enabled?: boolean; vad_threshold?: number; diarization_enabled?: boolean; coreml_enabled?: boolean; auto_download_coreml?: boolean }
export type AudioDevice = { index: string; name: string; is_default: boolean; device_type: AudioDeviceType }
/**
 * Device type classification for audio devices
 */
export type AudioDeviceType = "microphone" | "system_loopback" | "virtual_device" | "unknown"
export type BindingResponse = { success: boolean; binding: ShortcutBinding | null; error: string | null }
export type ClipboardHandling = "dont_modify" | "copy_to_clipboard"
export type CustomSounds = { start: boolean; stop: boolean }
export type DeveloperMode = 
/**
 * Developer mode is disabled
 */
"off" | 
/**
 * Auto-detect IDE/terminal apps
 */
"auto" | 
/**
 * Always use developer mode
 */
"always"
/**
 * Model info for display in UI
 */
export type DiarizationModelInfo = { name: string; description: string; size_bytes: number }
/**
 * Diarization status response
 */
export type DiarizationStatus = { available: boolean; enabled: boolean; models_downloaded: boolean; download_progress: number | null; error: string | null }
export type EngineType = "Whisper" | "Parakeet" | "Moonshine" | "GroqCloud"
/**
 * Export format options
 */
export type ExportFormat = "txt" | "srt" | "vtt" | "json" | "markdown" | "csv" | "html" | "docx" | "pdf"
/**
 * A single file transcription job
 */
export type FileTranscriptionJob = { id: string; file_path: string; file_name: string; file_size: number; status: FileTranscriptionStatus; progress: number; transcription: string | null; error: string | null; duration_seconds: number | null; created_at: number; completed_at: number | null }
/**
 * Status of a file transcription job
 */
export type FileTranscriptionStatus = "queued" | "processing" | "completed" | "failed" | "cancelled"
export type HistoryEntry = { id: number; file_name: string; timestamp: number; saved: boolean; title: string; transcription_text: string; post_processed_text: string | null; post_process_prompt: string | null }
export type LLMPrompt = { id: string; name: string; prompt: string }
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error"
/**
 * A single chunk of meeting audio
 */
export type MeetingChunk = { chunk_id: number; start_time_ms: number; end_time_ms: number; audio_path: string | null; transcription: string | null }
/**
 * A meeting history entry for the frontend
 */
export type MeetingHistoryEntry = { id: number; meeting_id: string; started_at: number; ended_at: number; duration_seconds: number; full_transcript: string; summary: string | null; action_items: string[] | null; chunk_count: number; saved: boolean }
/**
 * A complete meeting session
 */
export type MeetingSession = { meeting_id: string; started_at: number; ended_at: number | null; chunks: MeetingChunk[]; full_transcript: string | null; summary: string | null; action_items: string[] | null; duration_seconds: number | null }
/**
 * State of the meeting mode
 */
export type MeetingState = 
/**
 * No meeting in progress
 */
{ state: "Idle" } | 
/**
 * Meeting is currently recording
 */
{ state: "Recording"; meeting_id: string; started_at: number; chunk_count: number; binding_id: string } | 
/**
 * Meeting is being processed (transcription/summarization)
 */
{ state: "Processing"; meeting_id: string }
export type ModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; is_directory: boolean; engine_type: EngineType; accuracy_score: number; speed_score: number; coreml_url?: string | null; coreml_size_mb?: number; is_coreml_downloaded?: boolean; is_coreml_downloading?: boolean }
export type ModelLoadStatus = { is_loaded: boolean; current_model: string | null }
export type ModelUnloadTimeout = "never" | "immediately" | "min_2" | "min_5" | "min_10" | "min_15" | "hour_1" | "sec_5"
export type OverlayPosition = "none" | "top" | "bottom"
export type PasteMethod = "ctrl_v" | "direct" | "none" | "shift_insert" | "ctrl_shift_v"
export type PostProcessProvider = { id: string; label: string; base_url: string; allow_base_url_edit?: boolean; models_endpoint?: string | null }
export type RecordingRetentionPeriod = "never" | "preserve_limit" | "days_3" | "weeks_2" | "months_3"
export type ShortcutBinding = { id: string; name: string; description: string; default_binding: string; current_binding: string }
/**
 * A voice snippet that expands a trigger phrase into full text
 */
export type Snippet = { 
/**
 * Unique identifier for the snippet
 */
id: string; 
/**
 * The trigger phrase (e.g., "my email")
 */
trigger: string; 
/**
 * The expanded text (e.g., "john@example.com")
 */
expansion: string; 
/**
 * Whether to match case-sensitively
 */
case_sensitive?: boolean; 
/**
 * Whether to only match whole words (not partial matches)
 */
whole_word?: boolean }
export type SoundTheme = "marimba" | "pop" | "custom"
/**
 * Information about system audio capture capabilities
 */
export type SystemAudioInfo = { 
/**
 * Whether system audio capture is currently available (via virtual devices or native)
 */
available: boolean; 
/**
 * Whether native system audio capture is available (no drivers needed)
 */
native_available: boolean; 
/**
 * Whether additional setup is required
 */
requires_setup: boolean; 
/**
 * Platform-specific setup instructions
 */
setup_instructions: string; 
/**
 * List of detected system audio devices (virtual drivers)
 */
devices: string[]; 
/**
 * Platform-specific info about native capture
 */
native_info: string }
/**
 * Tone styles for transcription adjustment
 */
export type ToneStyle = 
/**
 * Professional, complete sentences (email, documents)
 */
"formal" | 
/**
 * Conversational, contractions allowed (messaging)
 */
"casual" | 
/**
 * Precise, jargon-friendly (IDEs, terminals)
 */
"technical" | 
/**
 * Minimal changes, faithful transcription
 */
"neutral"
/**
 * Segment with timing information for SRT/VTT export
 */
export type TranscriptSegment = { start_ms: number; end_ms: number; text: string; speaker: string | null }
/**
 * Configuration for a watched folder
 */
export type WatchFolderConfig = { id: string; path: string; enabled: boolean; recursive: boolean; auto_process: boolean }
/**
 * Status of a watch folder
 */
export type WatchFolderStatus = { folder_id: string; is_watching: boolean; last_error: string | null; files_processed: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
